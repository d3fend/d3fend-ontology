PREFIX ocsf: <https://schema.ocsf.io/1.4.0/ontology/>
PREFIX d3f: <http://d3fend.mitre.org/ontologies/d3fend.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX dcterms: <http://purl.org/dc/terms/>
PREFIX iter: <http://w3id.org/sparql-generate/iter/>
PREFIX fun: <http://w3id.org/sparql-generate/fn/>


GENERATE <https://schema.ocsf.io/1.4.0/erestriction> ( ?source ) {

  ######
  # Generate someValuesFrom restrictions for object properties
  GENERATE {
    ?this rdfs:subClassOf [ a owl:Restriction ;
		            owl:onProperty ?attribute ;
			    owl:someValuesFrom ?range
			  ] .
  }
  ITERATOR iter:JSONListKeys(?attributes) AS ?attributeName
  WHERE {
    BIND( IRI("https://schema.ocsf.io/1.4.0/ontology/" + ?attributeName) AS ?attribute )

    ?attribute a owl:ObjectProperty ;
       rdfs:range ?range .
  } .

  ######
  # Generate owl:qualifiedCardinality restrictions for required data properties with type and enum
  GENERATE {
    ?this rdfs:subClassOf [ a owl:Restriction ;
    	                    owl:onProperty ?attribute ;
			    owl:qualifiedCardinality "1"^^xsd:nonNegativeInteger ;
			    owl:onDataRange [
			       a rdfs:Datatype ;
			       owl:oneOf ( ?rdf_list )
			    ]
   		          ] .
    ?this rdfs:comment ?debug_comment1 .			  
    ?this rdfs:comment ?debug_comment2 .			  
  }
  ITERATOR iter:JSONListKeys(?attributes) AS ?attributeName
  WHERE {
    # Generate the IRI for the attribute
    BIND( IRI("https://schema.ocsf.io/1.4.0/ontology/" + ?attributeName) AS ?attribute )

    # Ensure the attribute is a datatype property
    ?attribute a owl:DatatypeProperty ;
              rdfs:range ?range .

    # Extract the enumeration list from JSON
    BIND( fun:JSONPath( ?attributes, "$." + ?attributeName + ".enum") AS ?enum_object )

    # SPARQL-Geneterate Uses Jayway JsonPath @
    # https://github.com/json-path/JsonPath, the Jayway JsonPath
    # Evaluator should work to pull caption/description pairs in a
    # list (need caption string for class naming and descrption for
    # definition construction.) And it does in web sandbox:
    #
    # Using ocsf 1.4.0 json from ocsf-schema/events/network/file_activity.json:
    # https://jsonpath.fly.dev/ tool with pattern: "$.attributes.activity_id.enum.*~" on data from file_activity.json seems to work
    # In code here, but not in tool, this pattern: "$.attributes.activity_id.enum.keys()" works.
    #
    # Tool online problme noted here: https://github.com/json-path/JsonPath/issues/779
    #
    # The online web tool is 2.9.0-SNAPSHOT 2023-04-29 02:25:36 (and json-path-2.9.0 is latest release)
    #
    # /!\ But unpacking the actual sparql-generate-2.1.0.jar file has manifest with json-path 2.4.0 /!\
    #
    # With the right lib pre-pended
    # This works "JSONPath Plus": $.attributes.activity_id.enum.*~
    BIND( fun:JSONPath( ?enum_object, "$.keys()") AS ?enum_keys )

    # BIND(
    #      IF (
    # 	     BOUND(?enum_object),
    # 	     CONCAT("DEBUG1: ", ?attributeName, " | ", STR(?range), " | ", STR(?enum_object)),
    # 	     CONCAT("DEBUG1: ", ?attributeName, " | ", STR(?range))
    # 	 )
    #      AS ?debug_comment1
    # )	 
    BIND(
         IF (
	     BOUND(?enum_keys),
	     CONCAT("DEBUG2: Keys are \{", STR(?enum_keys), "\}."),
	     "DEBUG2 No keys extracted."
	 )
         AS ?debug_comment2
    )
    
    # Ensure the enumeration list is bound
    FILTER( BOUND(?enum_keys) ) # Should filter No keys extracted

    # TODO Enumerate over the keys

    # TODO Construct the RDF list for owl:oneOf
    # Something like: BIND(iter:RDFList(?full_enum_list) AS ?rdf_List)
  } .

#   ###### TODO
#   # Generate owl:qualifiedCardinality restrictions for required data properties with type but no enum
#   GENERATE {
#     ?this rdfs:subClassOf [ a owl:Restriction ;
#     	                    owl:onProperty ?attribute ;
# 			    owl:qualifiedCardinality "1"^^xsd:nonNegativeInteger ;
# 			    owl:onDatatype ?range
# 			  ] .
#   }
#   ITERATOR iter:JSONListKeys(?attributes) AS ?attributeName
#   WHERE {
#     BIND( IRI("https://schema.ocsf.io/1.4.0/ontology/" + ?attributeName) AS ?attribute )

#     ?attribute a owl:DatatypeProperty ;
#        rdfs:range ?range .

#     BIND( fun:JSONPath( ?attributes, "$." + ?attributeName + ".enum.keys()") AS ?enum_list )
#     FILTER( !BOUND(?enum_list) )
#   }

#   ###### TODO
#   # Generate someValuesFrom restrictions for non-mandatory, non-enumerated data properties
#   GENERATE {
#     ?this rdfs:subClassOf [ a owl:Restriction ;
#     	                    owl:onProperty ?attribute ;
# 			    owl:someValuesFrom ?range
# 			  ] .
#   }
#   ITERATOR iter:JSONListKeys(?attributes) AS ?attributeName
#   WHERE {
#     BIND( IRI("https://schema.ocsf.io/1.4.0/ontology/" + ?attributeName) AS ?attribute )

#     ?attribute a owl:DatatypeProperty ;
#        rdfs:range ?range .

#     BIND( fun:JSONPath( ?attributes, "$." + ?attributeName + ".enum.keys()") AS ?enum_list )
#     FILTER( !BOUND(?enum_list) )

#     BIND( fun:JSONPath( ?attributes, "$." + ?attributeName + ".required") AS ?attribute_required )
#     FILTER ( !BOUND(?attribute_required) || ?attribute_required != "required" )
#   }

}
ITERATOR iter:JSONPath(?source, "$", "$.@deprecated", "$.description", "$.caption", "$.name", "$.extends", "$.observable", "$.constraints", "$.profiles", "$.attributes", "$.associations", "$.category", "$.uid" )
AS ?object ?deprecated ?description ?caption ?name ?extends ?observable ?constraints ?profiles ?attributes ?associations ?category ?uid
WHERE {
  BIND(
    IF (
      ?name = "base_event",
      IRI("https://schema.ocsf.io/1.4.0/ontology/BaseEvent"),
      IRI("https://schema.ocsf.io/1.4.0/ontology/" + fun:camelCase(?caption) + "Event")
    ) AS ?this
  )
}
