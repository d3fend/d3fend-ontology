PREFIX ocsf: <https://schema.ocsf.io/1.4.0/ontology/>
PREFIX d3f: <http://d3fend.mitre.org/ontologies/d3fend.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX dcterms: <http://purl.org/dc/terms/>
PREFIX iter: <http://w3id.org/sparql-generate/iter/>
PREFIX fun: <http://w3id.org/sparql-generate/fn/>

# {
#     "$id": "https://schema.ocsf.io/1.4.0//json-schema.org/draft/2020-12/schema",
#     "title": "Event",
#     "description": "Event classes are particular sets of attributes and objects representing a log line or telemetry submission at a point in time. Event classes have semantics that describe what happened: either a particular activity, disposition or both.",
#     "allOf": [
#         {
#             "$ref": "common-event-object.schema.json"
#         },
#         {
#             "type": "object",
#             "properties": {
#                 "@deprecated": true,
#                 "description": true,
#                 "caption": true,
#                 "name": true,
#                 "extends": true,
#                 "constraints": true,
#                 "profiles": true,
#                 "attributes": true,
#                 "associations": {
#                     "type": "object",
#                     "description": "Associations indicate attributes in a schema which 'go together'. For example, if a schema has multiple users and multiple endpoints, associations can indicate which user attribute goes with which endpoint.",
#                     "additionalProperties": {
#                         "type": "array",
#                         "items": {
#                             "type": "string"
#                         }
#                     }
#                 },
#                 "category": {
#                     "type": "string",
#                     "description": "The category that the event belongs to."
#                 },
#                 "uid": {
#                     "type": "integer",
#                     "description": "A unique identifier for this event, must be unique within the category.",
#                     "minimum": 0,
#                     "maximum": 999
#                 },
#                 "observables": {
#                     "type": "object",
#                     "description": "Defines class-specific observables by attribute path.",
#                     "patternProperties": {
#                         "^[a-z0-9_]+(\\.[a-z0-9_]+)*$": {
#                             "$ref": "observable.schema.json"
#                         }
#                     },
#                     "additionalProperties": false
#                 }
#             },
#             "additionalProperties": false
#         }
#     ]
# }

GENERATE <https://schema.ocsf.io/1.4.0/event> ( ?source ) {
  ?this a owl:Class ;
    # rdfs:subClassOf ?superClass ; # Superclass identified by the extends property in OCSF, but defer to later pass since won't know if generated at any given call to this GENERATE
    ocsf:name ?name ;
    rdfs:label ?caption ;
    dcterms:description ?description ;
    ocsf:associations ?associations ;
    ocsf:extends ?extends .

  # NOTE: ?category not always defined on individual event classes,
  # category classes must already have been generated in run or input
  # graph; i.e., this OPTIONAL isn't work-around for first pass.
  GENERATE {
    ?this ocsf:category ?categoryClass .
  } WHERE {
    ?categoryClass ocsf:name ?category_name .
  } .

  GENERATE {
    ?this ocsf:profiles ?profile .
  }
  ITERATOR iter:JSONPath(?profiles, "$[*]") AS ?profile .

  GENERATE {
    ?this ocsf:constraints ?constraints .
  }
  WHERE {
    FILTER (STR(?constraints) != "\{\}")
  } .
  
}

ITERATOR iter:JSONPath(?source, "$", "$.@deprecated", "$.description", "$.caption", "$.name", "$.extends", "$.observables", "$.constraints", "$.profiles", "$.attributes", "$.associations", "$.category", "$.uid" ) AS ?object ?deprecated ?description ?caption ?name ?extends ?observables ?constraints ?profiles ?attributes ?associations ?category ?uid

WHERE {
  BIND( IF (?name = "base_event",
            IRI("https://schema.ocsf.io/1.4.0/ontology/BaseEvent"),
  	    IRI("https://schema.ocsf.io/1.4.0/ontology/" + fun:camelCase(?caption) + "Event")
	    ) AS ?this )
  # We need to bind the ?category_name for matching to something.  If it is unbound it should not match,
  # but if unbound it is UNDEF and any old thing will match.... crazy PITA!  May be able to test and
  # filter in the WHERE clause (in theory) but didn't get that way to work, so there's this:
  BIND( IF (BOUND(?category),
  	    ?category,
	    "") AS ?category_name )
}
